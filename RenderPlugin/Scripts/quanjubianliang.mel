//----------------火星mel基础------------------

getAttr defaultRenderGlobals.currentRenderer;//获取当前渲染器
setAttr defaultRenderGlobals.currentRenderer -type "string" "arnold"; //设置默认渲染器为arnold


string $whatrender = `getAttr defaultRenderGlobals.currentRenderer`;
print("the current renderer is "+$whatrender+"\!");//获取当前渲染器并且输出渲染器名字 还加了！号

//----------------------------检查并切换around渲染器--------------------------
string $whatrender = `getAttr defaultRenderGlobals.currentRenderer`;
print("the current renderer is "+$whatrender+"\!");
print("\n");
if($whatrender=="arnold"){
    print ("渲染器是正确的");
}
else{
     print ("渲染器不是arnold，切换了");
     setAttr defaultRenderGlobals.currentRenderer -type "stri   ng" "arnold";
}
setAttr defaultRenderGlobals.currentRenderer -type "string" "arnold";

//----------------------------if语句--------------------------
int $counter;
if(frame==1){
$counter=200;
}else{
   $counter=$counter-1;
}
setAttr textForBevel1.text -type "string" $counter;


//----------------------------else if语句--------------------------
int $counter;
int $n;
if(frame==1){
$counter=200;
$n=1;
}else if(frame==5*$n){
    $n=$n+1;
   $counter=$counter-1;
}
setAttr textForBevel1.text -type "string" $counter;


//----------------------------window唯一--------------------------
if(`window -ex $window`){
    deleteUI -window $window;
}
string $window=`window -t "001"
                -wh 300 200
                     my1Window`;
    showWindow;

//----------------------------for in循环--------------------------
    proc keyTX(){
    string $sel[] = `ls -sl`;
    for($myObject in $sel){
   setKeyframe -at "translateX";}
}

//-----------------求出文件名字  文件名和灯光名字一致 删除大纲对应灯光的时候也方便--------------------
// string $fileName = `file -q -sceneName -shortName`;  得到文件名和路径  -shortName 加上这个不返回路径，只返回文件名
//substituteAllString(要被更改的字符串,要被替换掉的字符串,要被添加的字符串)

string $fileName = `file -q -sceneName -shortName`;
$fileName = substituteAllString($fileName,".ma","");
int $counter;
$counter = $counter+1;
print($counter);
print("\n");
file -rename ($fileName+$counter+".ma");
file -s -type "mayaAscii";
print("just Saved "+($fileName+$counter+".ma"));

 //---------------------------------match命令的用法 -------------------------------------
string $fileName = `file -q -sceneName -shortName`;
$fileName = substituteAllString($fileName,".ma","");
string $stringNumber = `match "[0-9]+" $fileName`; //match返回第二个字符串与第一个字符串相匹配的内容
int $n=$stringNumber;     //将字符串类型的变量转换为整型，用于数字累加 新定义一个整数，数字就是字符串的值
$n=$n+1;
$fileName = substituteAllString($fileName,$stringNumber,"");  //到这里实现了文件名后面的数字清除
                      
file -rename ($fileName+$n+".ma");
file -s -type "mayaAscii";
print("just Saved "+($fileName+$n+".ma")); //到这里代码实现了文件名在原来基础上 +1  
//但是这里只能执行文件名带数字的，对于文件名不带数字的文件，一旦执行就会崩溃
//这里的思路就是加入if 条件判断
//-----------------------------------------------------------------------------------------------------
string $fileName = `file -q -sceneName -shortName`;
$fileName = substituteAllString($fileName,".ma","");
string $stringNumber = `match "[0-9]+" $fileName`; 
int $n;
if($stringNumber==""){   //意思是如果stringNumber里面是空的
 $n = 1;               //这里的思路就是加入if 条件判断
}  else{                 //如果有数字的话就执行以下内容
    $n=$stringNumber;    
    $n=$n+1;
    $fileName = substituteAllString($fileName,$stringNumber,"");
}              

                      
file -rename ($fileName+$n+".ma");
file -s -type "mayaAscii";
print("just Saved "+($fileName+$n+".ma"));

//----------------------------------addAttr命令--------------------------------------
//新加入一些属性，比如宝哥要的高低摸切换，加入一个切换参数
addAttr -ln "controlColor" -usedAsColor -attributeType float3 //float3意思是rgb三个
addAttr -ln "red" -at "float" -parent "controlColor";
addAttr -ln "green" -at "float" -parent "controlColor";
addAttr -ln "blue" -at "float" -parent "controlColor";
//----------------------------------connectAttr强制链接属性--------------------------------------
string $sel[]=`ls -lt`;
for($myObject in $sel){
    connectAttr -f locator1.controlColor ($myObject".color"); //强制链接属性
    connectAttr -f locator1.contolLightsIntensity ($myObject".intensity");
   
}

//----------------------------------python部分--------------------------------------
//-class1
import maya.cmds as cmds   #这样下方的cmds.就可以代表maya.cmds了 缩减的写法
cmds.polySphere()
cmds.select("pSphere2")
print "hello"
//-class2
myString = "this is my first python string" //不用$符号来定义 它自己判断这是个字符串
print myString
// 在Python中使用变量，使用mel的代码
import maya.cmds as cmds   #这样下方的cmds.就可以代表maya.cmds了 缩减的写法
myList = cmds.polySphere() 
print ("the object is "+myList[0]) #这样就输出第一个信息
//-class3 eval的使用！ 
import maya.mel as mel
help(maya.mel) // 发现只有一个函数eval（） 这函数会使用mel自己的解释程序

//同样一个命令对比 
setAttr pSphere1.translateY 10;  //maya

mySphere=maya.cmds.polySphere()
maya.mel.eval("setAttr pSphere1.translateY 10") //eval里将maya命令原样放进去

//第一行是py命令 第二行eval里是mel 但是有mySphere这个py变量 所以引号内的格式要注意“”的应用 
mySphere=maya.cmds.polySphere()
maya.mel.eval("setAttr "+ mySphere[0]+".translateY 10") 


//--------------------aboutcg mel 基础---------------------
file -f -new  //强制新建 问都不问是否保存
/* 1就是1，这就是常量  变量就是1变成2 2变成3等等
    整数int  浮点float 矢量vector 字符串string 
声明变量的时候用$，后面可以跟任意字母和单词，但不可以是 $1数字   int $a =10; float $b = 3.14
创建个小球并且随机y轴*/
float $y = rand(0,5);
setAttr "pSphere1.translateY" $y;
print $y;

int $z = rand(0,5);
setAttr "pSphere1.translateY" $z;
print $z;

/*                     矢量                        */ 
vector $v = <<0,0,0>>;
print ($v.x);  //矢量会有3个值
vector $rgb = <<rand(0,1),rand(0,1),rand(0,1)>>;
particleShape1.rgbPP = $rgb;    //创建给粒子的rgbPP属性上，

/*                    字符串                       */ 
string $name = "pSphere" + int(rand(1,4));   //1-3中随机切换
select -r $name;
print $name;
//或者使用另一个方法
string $newName[] = {"pSphere1","pSphere2","pSphere3"};
select -r $newName[int(rand(0,3))];  //要定义随机的数据类型 int 还是float 
//或者使用另一个方法
string $newName[] = {"pSphere1","pSphere2","pSphere3"};
int $suiji = rand(0,3);     //我自己定义了整数变量，里面放了随机函数
select -r $newName[$suiji];  //要定义随机的数据类型 int 还是float 
print ($suiji);

/*                    数组array                       */ 
int $int[] = {1,3888,-56,0,58};  //整数类型的数组
float $f[] = {1.314,3.14,-8.66826};  //浮点类型的数组
string $ss[] = {"dota","lol","gta","cs"};    //字符串类型的数组  用双引号隔开
print $ss[2];
size($ss);                                     //测量命令size的使用
print $f[size($f)-1];                  //求出最后一位技巧
print $f[0];                       //求出第一位技巧

//字符串数组可以自己手动定义每一个值，也可以用mel返回值用 `ls -sl`
string $xuanzede[] = `ls -sl`; //选择谁就把谁的名字列出来


/*-----------------------------------------条件语句----------------------------------/ 
/*  条件判定符
    if else 基础语法
    其他条件    */
    
条件判定符   ==   >  <   >=   <=   !=
*if 执行成立条件 
*else 执行不成立条件
*if（条件）{条件成立执行；}
*else{条件不成立执行；}
//例子
int $a = 10;
if($a==5){print "deng yu 5";}
else{print "budengyu 5";}
//例子
int $a = 10;
if($a>5){print "dayu 5";}
else{print "xiaoyu 5";}

//如果要随机选择大于50个灯光，不够不执行下一步    (数组和条件语句结合的例子)
string $dengguangshu[]=`ls -sl`;
if(`size($dengguangshu)`>50){print "enough!";}
else{
    print "not enough 50 !";
}

//particle tool 创建粒子网格 工具里勾上particle grid
if(particleShape1.particleId%2==0){particleShape1.index=0;}  //%是除余的意思
else{particleShape1.index=1;}

//其他条件案例 
*存在与否 1代表存在 0代表不存在

if(0){print "fine!";}
else{print "not good ! ";}

// 条件判断与 建立窗口 的应用 
if (`window -ex win1`)   //这就是条件判断是否存在
{deleteUI win1;}
window -t "cj window"  win1;  //这个 win1 是需要给 window 一个名字用于后台激活的
showWindow win1;

/*----------------------------------------- 循环  ----------------------------------/ 
循环用来做批量操作，在任何语言中都非常重要 不会循环的话语言可以说白学了
white循环    
for循环      
for in循环（适合更加复杂的情况） */
                                         while 循环的基本格式 

int $x = 起始条件；   //声明一个整数变量作为循环的起始条件
while（$x<结束条件）  //这个变量是大于 小于某个条件  做多少次，执行多少次任务
{
    $x的变化方式；
    mel指令；
}
//例子
int $x = 0;     //起始条件
while($x<100)   //结束条件
{
    $x=$x+1;    //变化方式
print ($x+"\n");                //做的任务
}

      //如果忘记洗了变化方式 那么就会陷入死循环，maya一会就崩了
      int $y = 0;
      while ($y<100)
      {
          print ($y);       //缺了变化方式，成了死循环 
      }


                                        for 循环的基本格式   //nero比较喜欢用for循环， 不容易忘掉变化方式，因为都在一块
int $i;
for($i=起始条件；$i<结束条件；$i变化方式)     //因为都在一块，不太容易写错，逻辑清晰
{
    mel指令；
}
//实际案例
        int $i;
        for ($i=0;$i<100;$i++)    //$i++也可以写成 $i=$i+1
        {
            print ($i);   //这里的mel指令 比如是sphere   这样就会建100个小球 
        }
//------------------下面的拆字符串非常的重要-----------------------------
int $i;
for ($i=0;$i<100;$i++)
{
Sphere;
setAttr ("nurbsSphere1.translateX") 1;    //这里要拆字符串了 球的这个属性先加上括号和引号
}

setAttr ("nurbsSphere1.translateX") 1;//拆为下面这个
setAttr ("nurbsSphere"+($i+1)+".translateX") (rand(-5,5));  
//把1改成2“”,2引号中间加2++，2加号中间加2个（），小括号里才是变量。

//比如要改100盏灯的衰减方式 
int $i;
for($i=0;$i<100;$i++)
{
    setAttr ("pointLightShape"+($i+1)+".decayRate") 1;
}

                            ----------    for in   循环 -----------
/*for in 循环有别与之前的for 和while 循环（递增和递减的，类似于顺序变化的循环）
而for in 循环更加的灵活，它定义的是数组，做的循环是数组内的每一个元素做一次事情*/
定义数组；
for（新变量 in 数组）
{
    mel指令；
}
//例子
int $aa[] = {1,2,3,4,7,13,341,66,45};
for ($bb in $aa)    //这里的bb指的就是每一个变量
{
print ($bb+" ");
}
/*例子 建了很多灯光 如果想让中间选择的衰减，其他的不衰减，这样的物体名称就不连续了，需要for in 来做
如果想选择形状节点，而不是灯光的变换节点 就是小键盘的 上 下  
*/
pickWalk -d down;         //意思是选择什么都无所谓，都会先按 “下”，再执行将名称注入列表
string1 $select[]=`ls -sl`;  //把选择物体的名称列入数组里
for($lightName in $select)   //$lightName相当于$sel里的每一个元素
{
    setAttr ($lightName+".decayRate") 1;  //$lightName是变量 .decayrate是字符串不能直接连，需要.decayrate加上+和“ ”
}


------------------------------ ---------- mel程序指令  ----------------------------------
程序指令（procdure）的作用
1.简化复杂脚本
2.带有ui的插件
3.proc间互相调用返回值

程序指令的基本格式
·global proc  返回值类型 指令名称（依据值）//返回值类型 和 依据值 不是必须要写的
{
    mel指令；
}
//什么是依据值 rand（0,10） 0和10就是rand的依据值
global proc hello()
{
    print "hello world ! ";
}
//之后直接输入hello就可以了
global proc bjdx(float $a, float $b)    //这里就输入了依据值
{
    if ($a>$b) {print ($a+" is bigger ! ");}  //这里的；分号 因为是条件语句，分号要写在大括号的里面
    else if ($a==$b) {print ("they are same ! ");}     //这里用到了 else if 语句
    else  {print ($b+" is bigger ! ");}
}
//先声明以上内容 在执行下面这行
bjdx 3.14 3.5;
//复杂点的案例 比较粒子数的大小
//思路：1.取得两堆粒子的数量  2.比较大小 3.print出来

global proc lizi()
{
    pickWalk -d down;  //选择形状节点
    string $sel[]=`ls -sl`;  //求得粒子形状节点名字
    
    int $lizi1count=`getAttr ($sel[0]+".count")`; //得到了选择的第一个物体的粒子数
    int $lizi2count=`getAttr ($sel[1]+".count")`;  //得到了选择的第一个物体的粒子数
    
    if($lizi1count>$lizi2count){print ($sel[0]+" is bigger ! "+$lizi1count);}   //比较大小
    else {print ($sel[1]+" is bigger ! "+$lizi1count);}
}
lizi;   //选择2个粒子 执行即可 这就算调用了
//************************************************************************************
global proc string liziB()
{
    pickWalk -d down;  
    string $sel[]=`ls -sl`;  
    
    int $lizi1count=`getAttr ($sel[0]+".count")`; 
    int $lizi2count=`getAttr ($sel[1]+".count")`; 
    
    if($lizi1count>$lizi2count)
{
        print ($sel[0]+" is bigger ! ");
        return ($sel[0]);                    //用到了返回值 return
}  
    else 
{
        print ($sel[1]+" is bigger ! ");
        return ($sel[1]);
}
}

global proc yincangduode()   //新建了一个程序指令 作用是隐藏粒子数多的
{
    select -r `liziB`;     //选择刚才得到的多的一个
    pickWalk -d up;
    string $name[]=`ls -sl`;  //列出选的粒子的名字
    setAttr ($name[0]+".visibility") 0;  //使其不可见
}

liziB;  //选择2个粒子 执行即可 这就算调用了
yincangduode;  //执行就会隐藏多的那一个


//--------------------------- mel ui 基础--------------------------------------
窗口创建的格式
·窗口基础指令
·window 后缀指令 窗口名；
·布局声明；
·基础元素；
·showWindow窗口名；

//加一个判定是否存在的
window myWin;
showWindow myWin;
window -ex myWin;  //只输入这行会得到1返回值，意思是存在与否为1存在
if  (`window -ex myWin`)   //用if条件配合删除ui的运用 
deleteUI myWin;   
{deleteUI myWin;}   //{}里加上 可执行的事情
//之后如果直接加button会出错 ，因为还没有布局声明

if (`window -ex myWin`)
{deleteUI myWin;}

window 
-t "非常的强"; -wh 300 500
myWin;    
//窗口的名称必须是英文，不能是汉子或数字  对window的设置要写在window后面， mywin之前
columnLayout; 
button;
button;     //button可以在 window myWin;和showWindow myWin;里自由书写
button; 
window  -e  //这行的意思是刷新一下 以免新加的按钮没有刷新
showWindow myWin;